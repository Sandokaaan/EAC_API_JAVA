/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package database;

import java.sql.SQLException;
import java.util.TreeSet;
import org.json.JSONArray;
import org.json.JSONException;
import org.json.JSONObject;

/**
 *
 * @author virtu
 */
public class DbManager {
    
    private static final String BLOCKS = "blockchain";
    private static final String TRANSACTIONS = "transactions";
    private static final String TXDETAILS = "txdetails";
    private static final String OUTPUTS = "outputs";
    private static final String SPENT = "spent";
    private static final String ADDRESSES = "addresses";
    private Database db = null; 
    private boolean connected = false;
    
    /*
    * Constructor - open a new connection to the database
    */    
    public DbManager() throws SQLException {
        db = new Database();
        createTables();         // create only if not exist
        connected = true;
    }
    
    /*
    * Close the connection to the database
    * The creator JSONArrayOf DbManager object must call close on finishing
    */
    public final void close() {
        db.close();
        connected = false;
    }
    
    /*
    * Create tables only if their do not exists
    */
    private void createTables() throws SQLException {
        System.out.print("Check/create tables ...");
        db.createTable(BLOCKS,
                "height INTEGER NOT NULL PRIMARY KEY",
                "hash CHAR(64) UNIQUE NOT NULL",
                "time INTEGER NOT NULL");
        db.createTable(TRANSACTIONS,
                "tx_id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY",
                "txid CHAR(64) NOT NULL");
        db.createTable(ADDRESSES,
                "addr_id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY",
                "address VARCHAR(90) NOT NULL");
        db.createTable(TXDETAILS,
                "tx_id BIGINT NOT NULL PRIMARY KEY",                
                "height INTEGER NOT NULL",
                "coinbase BOOLEAN",
                "ipfs VARCHAR(90)",
                "txcomment VARCHAR(252)");
        db.createTable(OUTPUTS, 
                "tx_id BIGINT NOT NULL",
                "vout SMALLINT NOT NULL",
                "addr_id BIGINT NOT NULL",
                "value DOUBLE",
                "PRIMARY KEY (tx_id, vout)");
        db.createTable(SPENT, 
                "tx_id BIGINT NOT NULL",
                "vout SMALLINT NOT NULL",
                "spending_tx_id BIGINT NOT NULL",
                "PRIMARY KEY (tx_id, vout)");
        db.command(String.format(
                "CREATE INDEX IF NOT EXISTS ihash ON %s(hash)"
                , BLOCKS));
        db.command(String.format(
                "CREATE INDEX IF NOT EXISTS itxid ON %s(txid)"
                , TRANSACTIONS));
        db.command(String.format(
                "CREATE INDEX IF NOT EXISTS iaddr ON %s(address)"
                , ADDRESSES));
        db.command(String.format(
                "CREATE INDEX IF NOT EXISTS iheight ON %s(height)"
                , TXDETAILS));
        db.command(String.format(
                "CREATE INDEX IF NOT EXISTS iaddro ON %s(addr_id)"
                , OUTPUTS));
        db.command(String.format(
                "CREATE INDEX IF NOT EXISTS itxido ON %s(tx_id)"
                , OUTPUTS));
        db.command(String.format(
                "CREATE INDEX IF NOT EXISTS istxids ON %s(tx_id)"
                , SPENT));
        db.command(String.format(
                "CREATE INDEX IF NOT EXISTS itxids ON %s(spending_tx_id)"
                , SPENT));
        System.out.println(" OK");
    } 


/*
* Section - methods for blocks
*/
    
    public int getBlockCount() {
        return db.count(BLOCKS);
    }
    
    public int addBlock(int height, String hash, int time) {
        return db.commandWithParams(
            "SET @PARAMS = (?,?,?); " +
            "MERGE INTO " + BLOCKS + 
                " (height, hash, time) KEY(height) " + 
                "VALUES (@PARAMS[0], @PARAMS[1], @PARAMS[2]); ",
            params(height, hash, time)    
        );
    }
    
    public JSONObject getBlock(String hash) {
        return selectFirstAsJSON(
            "SELECT * FROM %s WHERE hash='%s' LIMIT 1; ", 
            BLOCKS, hash
        );
    }    
    
    public JSONObject getBlock(int height) {
        return selectFirstAsJSON(
            "SELECT * FROM %s WHERE height=%d LIMIT 1; ", 
            BLOCKS, height
        );
    }
    
    public JSONObject getBestBlock() {
        return selectFirstAsJSON(
            "SELECT hash FROM %s WHERE height=(SELECT MAX(height) FROM %1$s) LIMIT 1; ", 
            BLOCKS
        );        
    }

    public int getBestHeight() {
        return selectFirstAsJSON(
            "SELECT MAX(height) AS height FROM %s; ", 
            BLOCKS
        ).optInt("height", -1);          
    }

    public int getLowestHeight() {
        return selectFirstAsJSON(
            "SELECT MIN(height) AS height FROM %s; ", 
            BLOCKS
        ).optInt("height", -1);          
    }
    
    public String getBestHash() {
        return getBestBlock().optString("hash", "");
    }

    public String getBlockHash(int height) {
        return getBlock(height).optString("hash", "");
    }
    
    public int getBlockHeight(String hash) {
        return getBlock(hash).optInt("height", -1);
    }
    
    public TreeSet<Object> getAllHeights() {
        return DbResults.TreeSetOf(db.select(String.format(
            "SELECT height FROM %s ;",
            BLOCKS
        )));
    }
            

/*
* Section - methods for transactions
*/
    
    public int addTransaction(String txid) {
        return db.commandWithParams(
            "SET @PARAMS = (?); " +
            "MERGE INTO " + TRANSACTIONS + 
                " (txid) KEY(txid) VALUES (@PARAMS[0]); ",
            params(txid)    
        );
    }
    
    public int addTransactionWithDetails(String txid, int height, String ipfs, String txcomment, boolean coinbase) {
        return db.commandWithParams(
            "SET @PARAMS = (?,?,?,?); " +
            "MERGE INTO " + TRANSACTIONS + " (txid) KEY(txid) VALUES (@PARAMS[0]); " +        
            "SET @TX_ID = (SELECT tx_id FROM " + 
                            TRANSACTIONS + 
                            " WHERE txid='" + txid + 
                            "' LIMIT 1); " + 
            "MERGE INTO " + TXDETAILS + 
                " (tx_id, height, ipfs, txcomment, coinbase) KEY(tx_id) " +
                " VALUES (@TX_ID, @PARAMS[1], @PARAMS[2], @PARAMS[3], " + 
                (coinbase?"TRUE":"NULL") + "); ",
            params(txid, height, ipfs, txcomment)    
        );
    }    
    
    public int getTransactionCount() {
        return db.count(TRANSACTIONS);
    }
    

/*
* Section - methods for transaction-outputs
*/
    
    public int addTxOut(String txid, int vout, String address, double value) {
        return db.commandWithParams(
            "SET @PARAMS = (?,?,?); " +
            "MERGE INTO " + ADDRESSES + " (address) KEY(address) VALUES (@PARAMS[1]); " +        
            "SET @ADDR_ID = (SELECT addr_id FROM " + ADDRESSES + 
                " WHERE address='" + address + "' LIMIT 1); " +                     
            "SET @TX_ID = (SELECT tx_id FROM " + TRANSACTIONS + 
                " WHERE txid='" + txid + "' LIMIT 1); " +         
            "MERGE INTO " + OUTPUTS + 
                " (tx_id,vout,addr_id,value) KEY(tx_id,vout) " +
                "VALUES (@TX_ID, @PARAMS[0], @ADDR_ID, @PARAMS[2]); ",
            params(vout, address, value)    
        );
    }    

/*
* Section - methods for transaction-spent
*/
    
    public int addTxSpent(String src_txid, int src_vout, String spending_txid){
        return db.commandWithParams(
            "SET @PARAMS = (?,?); " +
            "MERGE INTO " + TRANSACTIONS + 
                " (txid) KEY(txid) VALUES (@PARAMS[0]); " +                    
            "SET @SRC_TX_ID = (SELECT tx_id FROM " + TRANSACTIONS + 
                                    " WHERE txid='" + src_txid + 
                                    "' LIMIT 1); " +  
            "SET @SPENDING_TX_ID = (SELECT tx_id FROM " + TRANSACTIONS +
                                    " WHERE txid='" + spending_txid + 
                                    "' LIMIT 1); " +   
            "MERGE INTO " + SPENT + 
                " (tx_id, vout, spending_tx_id) KEY(tx_id,vout) " +
                "VALUES (@SRC_TX_ID, @PARAMS[1], @SPENDING_TX_ID); ",
            params(src_txid, src_vout)    
        );        
    }
    
/*
* Section JSONArrayOf private supporting methods    
*/
    
    private JSONArray selectAsJSON(String query, Object...objects){
        return DbResults.JSONArrayOf(db.select(String.format(query, objects)));
    }
    
    public JSONArray selectAsJSON(String query){
        return DbResults.JSONArrayOf(db.select(query));
    }
    
    private JSONObject selectFirstAsJSON(String query, Object...objects){
        return DbResults.JSONObjectOf(selectAsJSON(query, objects));
    }

    private Object[] objects(Object...objects){
        return objects;
    }
    
    private Object[] params(Object...params){
        return params;
    }
    
    /*
    * Section complex queries
    */
    
    public JSONObject getSyncStat() {
        return selectFirstAsJSON(
            "SELECT "
                + "CONVERT( 100*COUNT(*)/(1.0+MAX(height)), REAL ) AS sync, " 
                + "COUNT(*) AS count, "
                + "MAX(height) AS height "
            + "FROM " + BLOCKS + ";"
        );
    }
    
    public JSONArray getSendHistory(String address, int limit) {
        return selectAsJSON(
            "SELECT "
                + "a.address, "
                + "o.value, "
                + "o.vout, "
                + "d.height, "
                + "t.txid, "
                + "b.time, "
                + "b.hash, "
                + "t.tx_id, "
                + "d.ipfs, "
                + "d.txcomment "
            + "FROM ("
                + "SELECT * FROM transactions "
                    + "WHERE tx_id IN ("
                        + "SELECT s.spending_tx_id AS tx_id "
                        + "FROM ("
                            + "SELECT * FROM addresses "
                                + "WHERE address='" + address 
                            + "') AS a "
                        + "LEFT JOIN outputs AS o "
                            + "ON a.addr_id=o.addr_id "
                        + "LEFT JOIN spent AS s "
                            + "ON o.tx_id=s.tx_id AND o.vout=s.vout "
                    + ")"
            + ") AS t "
            + "LEFT JOIN txdetails AS d "
                + "ON t.tx_id=d.tx_id "
            + "LEFT JOIN blockchain AS b "
                + "ON d.height=b.height "
            + "LEFT JOIN outputs AS o "
                + "ON t.tx_id=o.tx_id "
            + "LEFT JOIN addresses AS a "
                + "ON o.addr_id=a.addr_id "
            + "LIMIT " + limit
        );
    }
    
    public JSONArray getReceivedHistory(String address, int limit) {
        return selectAsJSON(
            "SELECT "
                + "a.address, "
                + "o.value, "
                + "o.vout, "
                + "d.height, "
                + "t.txid, "
                + "b.time, "
                + "b.hash, "
                + "s.spending_tx_id, "
                + "d.ipfs, "
                + "d.txcomment, "
                + "d.coinbase "
            + "FROM ("
                + "SELECT * "
                + "FROM addresses "
                    + "WHERE address='" + address 
            + "') AS a "
            + "LEFT JOIN outputs AS o "
                + "ON a.addr_id=o.addr_id "
            + "LEFT JOIN txdetails AS d "
                + "ON o.tx_id=d.tx_id "
            + "LEFT JOIN spent AS s "
                + "ON o.tx_id=s.tx_id AND o.vout=s.vout "
            + "LEFT JOIN transactions AS t "
                + "ON o.tx_id=t.tx_id "
            + "LEFT JOIN blockchain AS b "
                + "ON d.height=b.height "
            + "LIMIT " + limit    
        );
    }
    
    public JSONArray rearrange(JSONArray received, JSONArray send){
        JSONArray rts = new JSONArray();
        try {
            int nReceived = received.length();
            int nSend = send.length();
            for (Object o : received) {
                JSONObject json = (JSONObject)o;
                if (json.has("coinbase")) {
                    json.remove("coinbase");
                    json.put("type", "mined");
                }
                else
                    json.put("type", "received");
                if (json.has("spending_tx_id")) {
                    json.remove("spending_tx_id");
                    json.put("spent", true);
                }
                else
                    json.put("spent", false);
                rts.put(json);
            }
            JSONObject tmp = new JSONObject();
            for (Object o : send) {
                JSONObject json = (JSONObject)o;
                String tx_id = "" + json.getInt("tx_id");
                json.remove("tx_id");
                JSONObject tx = tmp.has(tx_id) ? 
                                tmp.optJSONObject(tx_id) : 
                                new JSONObject();
                JSONArray outs = tx.has("outputs") ?
                                 tx.getJSONArray("outputs") :
                                 new JSONArray();
                if (!tx.has("txid"))
                    tx.put("txid", json.get("txid"));
                json.remove("txid");
                if (!tx.has("hash"))
                    tx.put("hash", json.get("hash"));
                json.remove("hash");
                if (!tx.has("height"))
                    tx.put("height", json.get("height"));
                json.remove("height");
                if (!tx.has("time"))
                    tx.put("time", json.get("time"));
                json.remove("time");
                if (!tx.has("type"))
                    tx.put("type", "send");
                outs.put(json);
                tx.put("outputs", outs);
                tmp.put(tx_id, tx);
            }
            tmp.keySet().forEach(key -> {
                rts.put(tmp.getJSONObject(key));
            }); 
        } catch(JSONException ex) {
            // log it or do nothing
        }
        return rts;
    }  
    
}
    
